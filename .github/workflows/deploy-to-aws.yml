name: Deploy to AWS Elastic Beanstalk

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allow manual triggering

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Fetch all history for proper versioning
        
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          cache: 'pip'  # Cache pip dependencies
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install awsebcli
          pip install awscli
          
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      
      - name: Verify IAM roles
        run: |
          echo "Verifying required IAM roles for Elastic Beanstalk..."
          
          # Function to check if a role exists
          role_exists() {
            aws iam get-role --role-name "$1" 2>/dev/null
            return $?
          }
          
          # Function to check if an instance profile exists
          profile_exists() {
            aws iam get-instance-profile --instance-profile-name "$1" 2>/dev/null
            return $?
          }
          
          # EC2 role
          if ! role_exists "aws-elasticbeanstalk-ec2-role"; then
            echo "Creating EC2 role..."
            
            # Create the EC2 role trust policy
            echo '{
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Principal": {
                    "Service": "ec2.amazonaws.com"
                  },
                  "Action": "sts:AssumeRole"
                }
              ]
            }' > ec2-trust-policy.json
            
            # Create the EC2 role
            aws iam create-role --role-name aws-elasticbeanstalk-ec2-role --assume-role-policy-document file://ec2-trust-policy.json
            
            # Attach necessary policies
            aws iam attach-role-policy --role-name aws-elasticbeanstalk-ec2-role --policy-arn arn:aws:iam::aws:policy/AmazonS3FullAccess
            aws iam attach-role-policy --role-name aws-elasticbeanstalk-ec2-role --policy-arn arn:aws:iam::aws:policy/AmazonECR-FullAccess
            aws iam attach-role-policy --role-name aws-elasticbeanstalk-ec2-role --policy-arn arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
            
            echo "EC2 role created successfully"
          else
            echo "EC2 role already exists"
          fi
          
          # Instance profile
          if ! profile_exists "aws-elasticbeanstalk-ec2-role"; then
            echo "Creating instance profile..."
            
            # Create the instance profile
            aws iam create-instance-profile --instance-profile-name aws-elasticbeanstalk-ec2-role
            
            # Add the role to the instance profile
            aws iam add-role-to-instance-profile --instance-profile-name aws-elasticbeanstalk-ec2-role --role-name aws-elasticbeanstalk-ec2-role
            
            echo "Instance profile created successfully"
          else
            echo "Instance profile already exists"
            
            # Check if role is attached to the profile
            PROFILE_INFO=$(aws iam get-instance-profile --instance-profile-name aws-elasticbeanstalk-ec2-role)
            if ! echo "$PROFILE_INFO" | grep -q "aws-elasticbeanstalk-ec2-role"; then
              echo "Attaching role to existing instance profile..."
              aws iam add-role-to-instance-profile --instance-profile-name aws-elasticbeanstalk-ec2-role --role-name aws-elasticbeanstalk-ec2-role || true
            fi
          fi
          
          # Service role
          if ! role_exists "aws-elasticbeanstalk-service-role"; then
            echo "Creating service role..."
            
            # Create the service role trust policy
            echo '{
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Principal": {
                    "Service": "elasticbeanstalk.amazonaws.com"
                  },
                  "Action": "sts:AssumeRole"
                }
              ]
            }' > service-trust-policy.json
            
            # Create the service role
            aws iam create-role --role-name aws-elasticbeanstalk-service-role --assume-role-policy-document file://service-trust-policy.json
            
            # Attach necessary policies to the service role
            aws iam attach-role-policy --role-name aws-elasticbeanstalk-service-role --policy-arn arn:aws:iam::aws:policy/service-role/AWSElasticBeanstalkService
            aws iam attach-role-policy --role-name aws-elasticbeanstalk-service-role --policy-arn arn:aws:iam::aws:policy/service-role/AWSElasticBeanstalkEnhancedHealth
            
            echo "Service role created successfully"
          else
            echo "Service role already exists"
          fi
          
          echo "IAM roles verification complete"
          
          # Wait a bit for IAM changes to propagate if any changes were made
          echo "Waiting for IAM changes to propagate..."
          sleep 20
          
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
      
      - name: Create ECR repository if it doesn't exist
        run: |
          aws ecr describe-repositories --repository-names distillnet || aws ecr create-repository --repository-name distillnet
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Check for model files
        id: check-models
        run: |
          if [ -d "app/models" ] && [ "$(ls -A app/models)" ]; then
            echo "Models directory exists and contains files"
            echo "models_exist=true" >> $GITHUB_OUTPUT
          else
            echo "Models directory does not exist or is empty"
            echo "models_exist=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Create minimal Dockerfile if needed
        run: |
          echo "Creating minimal Dockerfile..."
          cat > Dockerfile.minimal << 'EOL'
FROM python:3.9-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
RUN pip install --no-cache-dir streamlit

# Create a simple Streamlit app
RUN mkdir -p /app/app
RUN echo 'import streamlit as st\n\nst.set_page_config(page_title="DistillNet", layout="wide")\n\nst.title("DistillNet Image Classifier")\n\nst.write("This is a minimal version of the app for testing deployment.")\n\nst.success("Deployment successful!")' > /app/app/app.py

# Set environment variables
ENV PYTHONPATH=/app
ENV STREAMLIT_SERVER_PORT=8501
ENV STREAMLIT_SERVER_ADDRESS=0.0.0.0

# Expose port for Streamlit
EXPOSE 8501

# Run the Streamlit app
CMD ["streamlit", "run", "/app/app/app.py", "--server.port=8501", "--server.address=0.0.0.0"]
EOL
          
          echo "Contents of Dockerfile.minimal:"
          cat Dockerfile.minimal
      
      - name: Build and tag Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: distillnet
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "Listing files in app directory..."
          ls -la app/
          
          echo "Listing files in src directory..."
          ls -la src/
          
          echo "Listing files in src/models directory..."
          ls -la src/models/
          
          echo "Building Docker image using minimal Dockerfile..."
          # Build with verbose output to help debug issues
          DOCKER_BUILDKIT=1 docker build --progress=plain -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -t $ECR_REGISTRY/$ECR_REPOSITORY:latest -f Dockerfile.minimal .
          
          if [ $? -ne 0 ]; then
            echo "Docker build failed. Exiting."
            exit 1
          fi
          
          # Test the image locally
          echo "Testing Docker image locally..."
          docker run --rm -d --name distillnet-test -p 8501:8501 $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          sleep 10
          docker logs distillnet-test
          docker stop distillnet-test
          
          echo "Pushing Docker image to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
          
      - name: Create Dockerrun.aws.json
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: distillnet
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo '{
            "AWSEBDockerrunVersion": "1",
            "Image": {
              "Name": "'$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG'",
              "Update": "true"
            },
            "Ports": [
              {
                "ContainerPort": "8501",
                "HostPort": "80"
              }
            ],
            "Logging": "/app/logs",
            "Memory": 1024
          }' > Dockerrun.aws.json
          
          echo "Dockerrun.aws.json content:"
          cat Dockerrun.aws.json
          
      - name: Generate deployment package
        run: |
          # Create .ebextensions directory for configuration
          mkdir -p .ebextensions
          
          # Create Streamlit configuration
          echo 'option_settings:
            aws:elasticbeanstalk:application:environment:
              PYTHONPATH: "/app"
              STREAMLIT_SERVER_PORT: "8501"
              STREAMLIT_SERVER_ADDRESS: "0.0.0.0"' > .ebextensions/01_streamlit.config
          
          # Create nginx configuration to proxy requests to Streamlit
          echo 'files:
            "/etc/nginx/conf.d/proxy.conf":
              mode: "000644"
              owner: root
              group: root
              content: |
                upstream streamlit {
                  server 127.0.0.1:8501;
                }
                
                server {
                  listen 80;
                
                  location / {
                    proxy_pass http://streamlit;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header Host $http_host;
                    proxy_set_header X-NginX-Proxy true;
                    
                    # Specific for websockets
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade $http_upgrade;
                    proxy_set_header Connection "upgrade";
                    proxy_read_timeout 86400;
                  }
                }
          
            "/opt/elasticbeanstalk/hooks/appdeploy/post/99_restart_nginx.sh":
              mode: "000755"
              owner: root
              group: root
              content: |
                #!/bin/bash
                service nginx restart' > .ebextensions/02_nginx.config
          
          # Create CloudWatch Logs configuration
          echo 'files:
            "/opt/elasticbeanstalk/tasks/taillogs.d/streamlit.conf":
              mode: "000644"
              owner: root
              group: root
              content: |
                /app/logs/streamlit.log' > .ebextensions/03_logs.config
          
          # Create health check configuration
          echo 'option_settings:
            aws:elasticbeanstalk:application:
              Application Healthcheck URL: /
            aws:elasticbeanstalk:environment:process:default:
              HealthCheckPath: /
              Port: "80"
              Protocol: HTTP
              HealthCheckTimeout: 30
              HealthyThresholdCount: 2
              UnhealthyThresholdCount: 5' > .ebextensions/04_healthcheck.config
          
          # Create IAM configuration
          echo 'option_settings:
            aws:autoscaling:launchconfiguration:
              IamInstanceProfile: aws-elasticbeanstalk-ec2-role
            aws:elasticbeanstalk:environment:
              ServiceRole: aws-elasticbeanstalk-service-role' > .ebextensions/05_iam.config
          
          # Create zip file with all required files
          zip -r deploy.zip Dockerrun.aws.json .ebextensions
          
      - name: Initialize EB CLI
        run: |
          mkdir -p ~/.aws
          echo "[profile eb-cli]" > ~/.aws/config
          echo "aws_access_key_id=${{ secrets.AWS_ACCESS_KEY_ID }}" >> ~/.aws/config
          echo "aws_secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}" >> ~/.aws/config
          echo "region=${{ secrets.AWS_REGION }}" >> ~/.aws/config
          
          eb init distillnet --region ${{ secrets.AWS_REGION }} --platform docker
          
      - name: Deploy to Elastic Beanstalk
        run: |
          # Check if environment exists
          if eb status distillnet-env 2>/dev/null; then
            echo "Environment exists, deploying updates..."
            eb deploy distillnet-env --staged --debug
          else
            echo "Creating new environment..."
            # Create environment with minimal arguments
            SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-8)
            echo "Using simplified eb create command..."
            eb create distillnet-env \
              --cname distillnet-$SHORT_SHA \
              --elb-type application \
              --timeout 20 \
              --instance-type t2.small \
              --platform docker \
              --tags service=distillnet,environment=production \
              --debug
          fi
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
          
      - name: Post-deployment info
        run: |
          echo "Application deployed successfully to Elastic Beanstalk"
          CNAME=$(eb status distillnet-env | grep CNAME | awk '{print $2}')
          echo "Environment URL: http://$CNAME"
          echo "url=http://$CNAME" >> $GITHUB_OUTPUT 